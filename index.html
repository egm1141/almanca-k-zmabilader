<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mensch ärgere dich nicht — Einzeldatei</title>
<style>
  :root{
    --bg:#0f1117;            /* Hintergrund */
    --panel:#151823;         /* Panels */
    --text:#e6e8ef;          /* Text */
    --muted:#9aa0aa;         /* Hilfstext */
    --accent:#4ade80;        /* Akzente */
    --danger:#fb7185;        /* Kollisionsmoment */
    --grid:#1f2430;          /* Spielbrett Boden */
    --cell:#232838;          /* Zelle */
    --ring:#3b4050;          /* Pfad Hervorhebung */
    --speed:280ms;           /* Spielstein Bewegungsgeschwindigkeit */
  }

  /* Farbthemen (Spielersteine und Heimwege) */
  .p0 { --p:#60a5fa; --pLight:#93c5fd; }
  .p1 { --p:#f59e0b; --pLight:#fcd34d; }
  .p2 { --p:#10b981; --pLight:#6ee7b7; }
  .p3 { --p:#ef4444; --pLight:#fca5a5; }

  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display:grid; min-height:100vh; grid-template-rows:auto 1fr auto;
  }

  header, footer{
    background:var(--panel); padding:12px 16px; border-bottom:1px solid #1c1f2a;
  }
  header h1{ margin:0; font-size:18px; letter-spacing:.2px }
  header .sub{ color:var(--muted); font-size:12px }

  .wrap{
    display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px;
  }
  @media (max-width: 900px){
    .wrap{ grid-template-columns: 1fr; }
  }

  /* Kontrollfeld */
  .panel{
    background:var(--panel); border:1px solid #1c1f2a; border-radius:12px; padding:12px;
  }
  .panel h2{ margin:4px 0 8px; font-size:16px }
  .row{ display:flex; gap:8px; align-items:center; margin-bottom:8px }
  .btn{
    appearance:none; border:1px solid #2a2f3e; background:#1b1f2b; color:var(--text);
    padding:8px 12px; border-radius:10px; cursor:pointer; transition:150ms ease;
  }
  .btn:hover{ border-color:#374055; transform:translateY(-1px) }
  .btn:disabled{ opacity:.4; cursor:default }
  .badge{
    display:inline-flex; align-items:center; gap:6px;
    padding:6px 10px; border-radius:999px; background:#1b2030; border:1px solid #2a2f3e;
  }
  .dot{ width:10px; height:10px; border-radius:50%; background:var(--p) }

  .dice{
    width:56px; height:56px; background:#121625; border:1px solid #2a2f3e; border-radius:12px;
    display:grid; place-items:center; font-weight:700; font-size:20px; color:var(--accent);
    transition: transform 220ms ease;
  }
  .dice.shake{ transform:rotate(8deg) scale(1.05) }

  .log{
    height:140px; overflow:auto; background:#111523; border:1px solid #202536;
    border-radius:10px; padding:8px; font-size:12px; color:var(--muted);
  }
  .log b{ color:var(--text) }

  /* Spielbrett */
  .board{
    background:var(--grid); border:1px solid #1c1f2a; border-radius:18px;
    padding:16px; display:grid; place-items:center;
  }
  .grid{
    width:min(80vmin,780px); aspect-ratio:1/1;
    display:grid; grid-template-columns: repeat(11, 1fr); grid-template-rows: repeat(11, 1fr);
    gap:6px; padding:12px; background:#141827; border-radius:14px;
  }
  .cell{
    background:var(--cell); border-radius:8px; position:relative;
    box-shadow: inset 0 0 0 1px #2a2f3e;
  }

  /* Pfad: Kreiszellen leicht hervorgehoben */
  .ring{ box-shadow: inset 0 0 0 2px var(--ring); }

  /* Heimwege und Starthäuser */
  .home, .start{ outline:2px solid var(--p); }
  .home{ background:color-mix(in oklab, var(--pLight) 25%, var(--cell)); }
  .start{ background:color-mix(in oklab, var(--p) 14%, var(--cell)); }

  /* Spielstein */
  .piece{
    position:absolute; inset:6px; border-radius:12px; background:var(--p);
    display:grid; place-items:center; color:#0e131f; font-weight:800;
    box-shadow: 0 6px 14px color-mix(in oklab, var(--p) 30%, transparent);
    transform:translate(0,0); transition: transform var(--speed) cubic-bezier(.2,.7,.2,1);
    cursor:pointer; user-select:none;
  }
  .piece::after{
    content:""; width:70%; height:55%; border-radius:50%;
    background:color-mix(in oklab, white 20%, transparent);
  }
  .piece.hit{ animation: hit 320ms ease }
  @keyframes hit{
    20%{ transform:translate(0,-6px) scale(1.06) }
  }

  /* Gewinnbanner */
  .banner{
    position:absolute; inset:auto 16px 16px auto; background:#132034; color:var(--text);
    border:1px solid #243049; border-radius:12px; padding:10px 12px; font-size:13px;
    box-shadow: 0 12px 28px rgba(0,0,0,.35);
  }
  .banner .winner{ display:flex; align-items:center; gap:8px }
  .winner .dot{ width:12px; height:12px }

  /* Tooltip-ähnlicher kleiner Hinweis */
  .hint{
    position:absolute; inset:16px auto auto 16px; background:#162138; color:var(--muted);
    border:1px solid #243049; border-radius:10px; padding:8px 10px; font-size:12px;
  }
</style>
</head>
<body>
<header>
  <h1>Mensch ärgere dich nicht</h1>
  <div class="sub">Elegantes CSS, klare Logik, flüssige Bewegung. Einzeldatei, produktionsbereit.</div>
</header>

<div class="wrap">
  <div class="panel">
    <h2>Spielsteuerung</h2>
    <div class="row">
      <button id="btnStart" class="btn">Neues Spiel</button>
      <button id="btnDice" class="btn">Würfeln</button>
      <div id="dice" class="dice">—</div>
    </div>

    <div class="row">
      <span class="badge p0"><span class="dot"></span> Blau</span>
      <span class="badge p1"><span class="dot"></span> Orange</span>
      <span class="badge p2"><span class="dot"></span> Grün</span>
      <span class="badge p3"><span class="dot"></span> Rot</span>
    </div>

    <div class="row">
      <label class="badge"><input id="players" type="range" min="2" max="4" value="4" />
        <span>Spieleranzahl: <b id="playersVal">4</b></span>
      </label>
    </div>

    <div class="row" style="flex-direction:column; align-items:flex-start">
      <b>Regeln (Zusammenfassung):</b>
      <ul style="margin:6px 0 0; padding-left:16px; color:var(--muted)">
        <li>Mit einer 6 kommt ein Stein aus dem Start oder ein Stein bewegt sich weiter.</li>
        <li>Gibt es keinen gültigen Zug, wird die Runde übersprungen.</li>
        <li>Landet man auf einem gegnerischen Feld, wird der Stein "geschlagen" und kehrt zum Start zurück.</li>
        <li>Wenn alle Steine im Ziel sind, gewinnt der Spieler.</li>
      </ul>
    </div>

    <div class="row">
      <div class="log" id="log"></div>
    </div>
  </div>

  <div class="board">
    <div class="grid" id="grid"></div>
    <div class="banner" id="banner" style="display:none">
      <div class="winner"><span class="dot"></span><b id="winnerName">Gewinner</b> hat gewonnen!</div>
    </div>
    <div class="hint">Würfeln, gültige Steine blinken; klicken und bewegen.</div>
  </div>
</div>

<footer>
  <small>Sorgfältig erstellt für Egemen: Animation, Logik und visuelle Klarheit zusammen. Einfach anzupassen.</small>
</footer>

<script>
/* ========= Modell ========= */
const STATE = {
  players: 4,
  turn: 0,
  dice: null,
  pieces: [],  // {id, player, posType: 'start'|'ring'|'home', index: number}
  ring: [],    // 40 Zellen (0..39)
  homes: [[],[],[],[]], // jeder Spieler: 4 Zielzellen Indizes
  starts: [[],[],[],[]],// jeder Spieler: 4 Startzellen
  enterIndex: [0,10,20,30], // Einstiegspunkt jedes Spielers in den Ring
};

/* ========= Brettanordnung: 11x11 Grid ========= */
/* Ring-Pfad Koordinaten (ähnlich Mensch ärgere dich nicht Spiralpfad) */
const ringPath = [
  [5,0],[5,1],[5,2],[5,3],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],
  [10,5],[9,5],[8,5],[7,5],[6,5],[6,6],[6,7],[6,8],[6,9],[6,10],
  [5,10],[5,9],[5,8],[5,7],[5,6],[4,6],[3,6],[2,6],[1,6],[0,6],
  [0,5],[1,5],[2,5],[3,5],[4,5],[4,4],[4,3],[4,2],[4,1],[4,0]
]; // 40 Zellen

/* Starthäuser: vier Eckblöcke (4 Steine) */
const startBlocks = {
  0: [[0,0],[0,1],[1,0],[1,1]],          // Blau links-oben
  1: [[9,0],[9,1],[10,0],[10,1]],        // Orange rechts-oben
  2: [[9,9],[9,10],[10,9],[10,10]],      // Grün rechts-unten
  3: [[0,9],[0,10],[1,9],[1,10]],        // Rot links-unten
};

/* Zielpfade (4 Zellen): für jeden Spieler vom Ring-Eingang zur Mitte */
const homePaths = {
  0: [[1,5],[2,5],[3,5],[4,5]],
  1: [[5,1],[5,2],[5,3],[5,4]],
  2: [[9,5],[8,5],[7,5],[6,5]],
  3: [[5,9],[5,8],[5,7],[5,6]],
};

/* ========= Hilfsfunktionen ========= */
const gridEl = document.getElementById('grid');
const logEl  = document.getElementById('log');
const diceEl = document.getElementById('dice');
const banner = document.getElementById('banner');
const winnerName = document.getElementById('winnerName');

function log(msg){ const t = document.createElement('div'); t.innerHTML = msg; logEl.prepend(t); }
function key(x,y){ return `${x}-${y}`; }

function createCell(x,y, cls=''){
  const c = document.createElement('div');
  c.className = `cell ${cls}`;
  c.dataset.xy = key(x,y);
  c.style.gridColumnStart = x+1;
  c.style.gridRowStart = y+1;
  gridEl.appendChild(c);
  return c;
}

function findCellByXY([x,y]){ return gridEl.querySelector(`.cell[data-xy="${key(x,y)}"]`); }

/* ========= Brett aufbauen ========= */
function setupBoard(){
  gridEl.innerHTML = '';
  banner.style.display = 'none';
  // 11x11 allgemeine Zellen erstellen (für visuelle Vollständigkeit)
  for(let y=0;y<11;y++){
    for(let x=0;x<11;x++){ createCell(x,y); }
  }
  // Ring
  STATE.ring = ringPath.map((xy,i)=>{
    const cell = findCellByXY(xy);
    cell.classList.add('ring');
    cell.dataset.ring = i;
    return {xy, cell};
  });
  // Starts + Homes
  for(let p=0;p<4;p++){
    const cls = `p${p}`;
    STATE.starts[p] = startBlocks[p].map(xy=>{
      const c = findCellByXY(xy); c.classList.add(cls,'start'); return c;
    });
    STATE.homes[p]  = homePaths[p].map(xy=>{
      const c = findCellByXY(xy); c.classList.add(cls,'home'); return c;
    });
  }
}

/* ========= Spielsteine erzeugen ========= */
function createPieces(){
  STATE.pieces = [];
  for(let p=0;p<STATE.players;p++){
    for(let i=0;i<4;i++){
      const piece = document.createElement('div');
      piece.className = `piece p${p}`;
      piece.textContent = i+1;
      piece.dataset.player = p;
      piece.dataset.index  = i;
      piece.dataset.posType= 'start';
      piece.dataset.pos    = i; // Start-Zellen-Index
      piece.style.transform = 'translate(0,0)';
      STATE.starts[p][i].appendChild(piece);
      piece.addEventListener('click', ()=> onPieceClick(piece));
      STATE.pieces.push(piece);
    }
  }
}

/* ========= Spielablauf ========= */
function startGame(){
  setupBoard();
  createPieces();
  STATE.turn = 0;
  STATE.dice = null;
  diceEl.textContent = '—';
  log('<b>Neues Spiel:</b> Startspieler ist Blau.');
  highlightTurn();
}

function highlightTurn(){
  document.querySelectorAll('.badge').forEach(b=>{
    b.style.outline = '';
  });
  document.querySelectorAll('.badge.p'+STATE.turn).forEach(b=>{
    b.style.outline = '2px solid var(--accent)';
  });
}

/* Würfelwurf */
function rollDice(){
  diceEl.classList.add('shake');
  const val = Math.floor(Math.random()*6)+1;
  setTimeout(()=>{
    diceEl.classList.remove('shake');
    STATE.dice = val;
    diceEl.textContent = val;
    log(`<b>Würfel:</b> Spieler ${playerName(STATE.turn)} würfelt ${val}.`);
    indicateMovables();
    // Automatischer Pass: keine Bewegung möglich
    if(getMovables().length===0){
      log(`<b>Pass:</b> Kein gültiger Zug. Runde übersprungen.`);
      nextTurn();
    }
  }, 220);
}

/* Gültige Steine hervorheben */
function indicateMovables(){
  clearIndicators();
  getMovables().forEach(p=>{
    p.style.outline = '3px solid var(--accent)';
    p.style.filter = 'drop-shadow(0 0 6px var(--accent))';
  });
}
function clearIndicators(){
  STATE.pieces.forEach(p=>{ p.style.outline=''; p.style.filter=''; });
}

/* Zugberechnung */
function canMoveFromStart(piece){
  // Ohne 6 kann man nicht vom Start wegziehen
  if(STATE.dice !== 6) return false;
  const p = Number(piece.dataset.player);
  const enter = STATE.enterIndex[p];
  // Eingangszelle hat Gegner? Kann geschlagen werden; eigener Stein? Blockiert
  const occupant = pieceAtRing(enter);
  if(!occupant) return true;
  return Number(occupant.dataset.player) !== p;
}

function canMoveOnRing(piece){
  // Nicht im Start und nicht im Ziel, bewegt sich auf dem Ring
  if(piece.dataset.posType!=='ring') return false;
  const steps = STATE.dice;
  const p = Number(piece.dataset.player);
  const cur = Number(piece.dataset.pos); // Ring-Index
  const target = (cur + steps) % STATE.ring.length;

  // Zieleingang prüfen: exakte Eingangspunkt passieren für Zielweg
  const enter = STATE.enterIndex[p];
  // Ins Ziel gehen: vom Ring ins Ziel nur am Eingangspunkt mit exakter Schrittzahl
  const goingHome = (cur < enter && target >= enter) || (cur >= enter && (cur+steps)>= enter && (cur+steps)%40===enter);
  if(target === enter){
    // Erste Zielzelle leer oder kein Gegner (Zielzellen für Gegner nicht zugänglich)
    const home0 = STATE.homes[p][0];
    return !pieceInCell(home0);
  }

  // Normaler Ring-Schritt: Ziel hat eigenen Stein? Blockiert
  const occ = pieceAtRing(target);
  return !(occ && Number(occ.dataset.player)===p);
}

function canEnterHome(piece){
  if(piece.dataset.posType!=='ring') return false;
  const p = Number(piece.dataset.player);
  const cur = Number(piece.dataset.pos);
  const enter = STATE.enterIndex[p];
  const steps = STATE.dice;
  // Muss exakt auf Eingangspunkt landen
  if((cur + steps) % STATE.ring.length !== enter) return false;
  // Ziel 0 muss leer sein
  const home0 = STATE.homes[p][0];
  return !pieceInCell(home0);
}

function canMoveInsideHome(piece){
  if(piece.dataset.posType!=='home') return false;
  const p = Number(piece.dataset.player);
  const idx = Number(piece.dataset.pos); // Ziel-Index 0..3
  const target = idx + STATE.dice;
  if(target > 3) return false; // Zu viel gewürfelt, kann nicht einziehen
  const cell = STATE.homes[p][target];
  return !pieceInCell(cell);
}

/* Hilfsfunktionen: Stein in Ring/Ziel/Start-Zellen finden */
function pieceAtRing(rIndex){
  const cell = STATE.ring[rIndex].cell;
  return pieceInCell(cell);
}
function pieceInCell(cell){
  return [...cell.children].find(c=>c.classList.contains('piece'));
}

/* Klick-Bewegung */
function onPieceClick(piece){
  const p = Number(piece.dataset.player);
  if(p !== STATE.turn || STATE.dice===null) return;

  // Vom Start wegziehen
  if(piece.dataset.posType==='start' && canMoveFromStart(piece)){
    moveFromStart(piece);
    finalizeMove();
    return;
  }

  // Ins Ziel eintreten (Ring -> Ziel0)
  if(piece.dataset.posType==='ring' && canEnterHome(piece)){
    moveToHome(piece, 0);
    finalizeMove();
    return;
  }

  // Im Ziel vorankommen
  if(piece.dataset.posType==='home' && canMoveInsideHome(piece)){
    const target = Number(piece.dataset.pos) + STATE.dice;
    moveToHome(piece, target);
    finalizeMove();
    return;
  }

  // Auf dem Ring bewegen
  if(canMoveOnRing(piece)){
    const cur = Number(piece.dataset.pos);
    const target = (cur + STATE.dice) % STATE.ring.length;
    moveOnRing(piece, target);
    finalizeMove();
    return;
  }
}

/* Nach dem Zug: Gewinn prüfen, Runde, Würfel 6 = nochmal usw. */
function finalizeMove(){
  clearIndicators();
  checkWin();
  const again = (STATE.dice===6);
  STATE.dice = null;
  diceEl.textContent = '—';
  if(again){
    log(`<b>Glückwunsch:</b> 6 gewürfelt, nochmal würfeln!`);
  }else{
    nextTurn();
  }
}

/* Rundenwechsel */
function nextTurn(){
  STATE.turn = (STATE.turn + 1) % STATE.players;
  highlightTurn();
  indicateMovables(); // Info-Zweck leichtes Leuchten (ohne Würfel nicht sichtbar)
}

/* ========= Bewegungen ========= */
function moveFromStart(piece){
  const p = Number(piece.dataset.player);
  const enter = STATE.enterIndex[p];
  const enterCell = STATE.ring[enter].cell;

  // Gegner? Schlagen
  const occ = pieceInCell(enterCell);
  if(occ && Number(occ.dataset.player)!==p){
    sendToStart(occ);
    occ.classList.add('hit');
    setTimeout(()=> occ.classList.remove('hit'), 400);
    log(`<b>Schlag:</b> ${playerName(p)} hat gegnerischen Stein geschlagen!`);
  }

  const fromCell = STATE.starts[p][Number(piece.dataset.pos)];
  animateToCell(piece, fromCell, enterCell);
  piece.dataset.posType='ring';
  piece.dataset.pos= String(enter);
}

function moveOnRing(piece, target){
  const p = Number(piece.dataset.player);
  const targetCell = STATE.ring[target].cell;
  const occ = pieceInCell(targetCell);
  if(occ && Number(occ.dataset.player)!==p){
    sendToStart(occ);
    occ.classList.add('hit');
    setTimeout(()=> occ.classList.remove('hit'), 400);
    log(`<b>Schlag:</b> ${playerName(p)} hat gegnerischen Stein geschlagen!`);
  }
  const curCell = currentCell(piece);
  animateToCell(piece, curCell, targetCell);
  piece.dataset.posType='ring';
  piece.dataset.pos= String(target);
}

function moveToHome(piece, hIndex){
  const p = Number(piece.dataset.player);
  const targetCell = STATE.homes[p][hIndex];
  const curCell = currentCell(piece);
  animateToCell(piece, curCell, targetCell);
  piece.dataset.posType='home';
  piece.dataset.pos= String(hIndex);
}

function currentCell(piece){
  return piece.parentElement;
}

function sendToStart(piece){
  const p = Number(piece.dataset.player);
  const i = Number(piece.dataset.index);
  const target = STATE.starts[p][i];
  animateToCell(piece, piece.parentElement, target);
  piece.dataset.posType='start';
  piece.dataset.pos= String(i);
}

/* ========= Animation ========= */
/* Simuliert flüssige Bewegung innerhalb der Zelle mit translate */
function animateToCell(piece, fromCell, toCell){
  const a = fromCell.getBoundingClientRect();
  const b = toCell.getBoundingClientRect();
  const dx = (b.left - a.left);
  const dy = (b.top  - a.top);
  piece.style.transform = `translate(${dx}px, ${dy}px)`;
  // Tatsächliches DOM-Verschieben verzögert (nach Transition)
  setTimeout(()=>{
    piece.style.transform = 'translate(0,0)';
    toCell.appendChild(piece);
  }, parseInt(getComputedStyle(piece).getPropertyValue('--speed')));
}

/* ========= Gewinn ========= */
function checkWin(){
  for(let p=0;p<STATE.players;p++){
    const allHome = document.querySelectorAll(`.piece.p${p}[data-postype="home"], .piece.p${p}`).length>0
    const homeCount = [...document.querySelectorAll(`.piece.p${p}`)]
      .filter(pc=>pc.dataset.posType==='home' && Number(pc.dataset.pos)===3).length;
    // Einfacher Gewinn: alle vier Steine im Ziel und am weitesten (Index 3)
    const homeAll = [...document.querySelectorAll(`.piece.p${p}`)]
      .filter(pc=>pc.dataset.posType==='home').length===4;
    if(homeAll){
      banner.querySelector('.dot').style.background = getPlayerColor(p);
      winnerName.textContent = playerName(p);
      banner.style.display = 'block';
      log(`<b>Spiel beendet:</b> ${playerName(p)} hat gewonnen!`);
      disableDice();
      return true;
    }
  }
  return false;
}

function playerName(p){ return ['Blau','Orange','Grün','Rot'][p]; }
function getPlayerColor(p){ return getComputedStyle(document.documentElement).getPropertyValue(`--p`).trim(); }

/* ========= Bewegliche Steine ========= */
function getMovables(){
  if(STATE.dice===null) return [];
  const pieces = STATE.pieces.filter(pc=> Number(pc.dataset.player)===STATE.turn );
  return pieces.filter(pc=>{
    return canMoveFromStart(pc) || canEnterHome(pc) || canMoveInsideHome(pc) || canMoveOnRing(pc);
  });
}

/* ========= UI ========= */
const btnStart = document.getElementById('btnStart');
const btnDice  = document.getElementById('btnDice');
const playersRange = document.getElementById('players');
const playersVal   = document.getElementById('playersVal');

btnStart.addEventListener('click', ()=>{
  STATE.players = parseInt(playersRange.value,10);
  playersVal.textContent = STATE.players;
  enableDice();
  startGame();
});
btnDice.addEventListener('click', ()=>{
  if(btnDice.disabled) return;
  rollDice();
});

playersRange.addEventListener('input', ()=>{
  playersVal.textContent = playersRange.value;
});

function disableDice(){ btnDice.disabled = true; }
function enableDice(){ btnDice.disabled = false; }

/* Erste Einrichtung */
setupBoard();
</script>
</body>
</html>
